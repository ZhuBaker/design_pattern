https://blog.csdn.net/a314368439/article/details/72642653

http://ziyue1987.github.io/pages/2013/09/22/disruptor-use-manual.html#lockvscas

EventProcessor及其依赖关系
Disruptor定义了两种EventProcessor：BatchEventProcessor和WorkProcessor。两种EventProcessor都实现了Runnable接口
，在组装完成后可以直接放入线程中执行。

用户需要实现自己的EventHandler来告诉EventProcessor在收到消息的时候怎样处理。

用户还需要结合SequenceBarrier来构造各个EventProcessor之间及其和RingBuffer之间的依赖，关于依赖的定义，已经在上文解释过了。
这里需要说明的是，我们在使用Queue构造pipeline的时候，类似于接水管，每一个步骤需要哪些处理，就用Queue接过去，处理完成后再用Queue接到下一个步骤。
这种方式固然实现起来简单，但是消息需要穿过各个Queue，必要的时候还需要对消息进行复制，这会产生大量对Queue的并发访问操作，效率很低。
在Disruptor里，相邻的两个步骤被解释成步骤2中的EventProcessor依赖步骤1中的EventProcessor，消息在RingBuffer中依次被步骤1中的EventProcessor和步骤2中的EventProcessor处理。

不仅EventProcessor对RingBuffer有依赖，RingBuffer对EventProcessor也有反向依赖。RingBuffer需要保证在生产者比消费者快得情况下，
新生产的消息不会覆盖未被完全消费（即被所有EventProcessor处理）的消息。为了做到这一点，
RingBuffer会追踪有依赖关系的EventProcessor中最小的Sequence（如果不能根据依赖关系判断Sequence大小，则全部追踪）。
需要追踪的Sequence会加入到RingBuffer的gatingSequences数组中。下面通过几个use case说明两种EventProcessor和RingBuffer如何组装。